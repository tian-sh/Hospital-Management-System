# -*- coding: utf-8 -*-
"""CSC242 Group Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X8lW3VwpAxz5mBaxbry5g2kuJWBF3ksS

### **Sorting Techniques through different Data Structures**


---

##### **Importing all modules needed**
"""

import random as rd

"""##### **Data Structures and Algorithms Used & Reasoning**

##### Array, Priority Linked List
"""

class Array(object):
    """Represents an array."""

    def __init__(self, capacity, fillValue = None):
        """Capacity is the static size of the array.
        fillValue is placed at each position."""
        self._items = list()
        for count in range(capacity):
            self._items.append(fillValue)

    def __len__(self):
        """-> The capacity of the array."""
        return len(self._items)

    def __str__(self):
        """-> The string representation of the array."""
        return str(self._items)

    def __iter__(self):
        """Supports iteration over a view of an array."""
        return iter(self._items)

    def __getitem__(self, index):
        """Subscript operator for access at index."""
        return self._items[index]

    def __setitem__(self, index, newItem):
        """Subscript operator for replacement at index."""
        self._items[index] = newItem

class AbstractCollection(object):
    """An abstract collection implementation."""

    # Constructor
    def __init__(self, sourceCollection = None):
        """Sets the initial state of self, which includes the
        contents of sourceCollection, if it's present."""
        self._size = 0
        if sourceCollection:
            for item in sourceCollection:
                self.add(item)

    # Accessor methods
    def __len__(self):
        """-> The number of items in self."""
        return self._size

    def isEmpty(self):
        return len(self) == 0

    def __str__(self):
        """Returns the string representation of self."""
        return "[" + ", ".join(map(str, self)) + "]"

    def __add__(self, other):
        """Returns a new collection consisting of the
        items in self and other."""
        result = type(self)(self)
        for item in other:
            result.add(item)
        return result

    def __eq__(self, other):
        """Returns True if self equals other,
        or False otherwise."""
        if self is other: return True
        if type(self) != type(other) or \
           len(self) != len(other):
            return False
        otherIter = iter(other)
        for item in self:
            if item != next(otherIter):
                return False
        return True

class Node(object):
    """Nodes for singly linked structures."""

    def __init__(self, data, next = None):
        """Instantiates a Node with default next of None"""
        self.data = data
        self.next = next

    def __str__(self):
        return str(self.data)

class LinkedQueue(AbstractCollection):
    """A link-based queue implementation."""

    # Constructor
    def __init__(self, sourceCollection = None):
        """Sets the initial state of self, which includes the
        contents of sourceCollection, if it's present."""
        self._front = self._rear = None
        AbstractCollection.__init__(self, sourceCollection)

    # Accessor methods
    def __iter__(self):
        """Supports iteration over a view of self."""
        cursor = self._front
        while cursor is not None:
            yield cursor
            cursor = cursor.next

    def peek(self):
        """
        Returns the item at the front of the queue.
        Precondition: the queue is not empty.
        Raises: KeyError if the stack is empty."""
        if self.isEmpty():
            raise KeyError("The queue is empty.")
        return self._front.data

    def add(self, item):
        """Adds item to the rear of the queue."""
        newNode = Node(item, None)
        if self.isEmpty():
            self._front = newNode
        else:
            self._rear.next = newNode
        self._rear = newNode
        self._size += 1

    def pop(self):
        """
        Removes and returns the item at the front of the queue.
        Precondition: the queue is not empty.
        Raises: KeyError if the queue is empty.
        Postcondition: the front item is removed from the queue."""
        if self.isEmpty():
            raise KeyError("The queue is empty.")
        oldItem = self._front.data
        self._front = self._front.next
        if self._front is None:
            self._rear = None
        self._size -= 1
        return oldItem

class LinkedPriorityQueue(LinkedQueue):
    """A link-based priority queue implementation."""

    def __init__(self, sourceCollection = None):
        """Sets the initial state of self, which includes the
        contents of sourceCollection, if it's present."""
        LinkedQueue.__init__(self, sourceCollection)

    def add(self, item):
        """Adds item to its proper place in the queue."""
        if type(item) != type(Patient(1,'Dummy')):
            LinkedQueue.add(self,item)
        else:
            if self.isEmpty() or item.get_urgency() >= self._rear.data.get_urgency():
                LinkedQueue.add(self, item)
            else:
                probe = self._front
                trailer = None
                while item.get_urgency() >= probe.data.get_urgency():
                    trailer = probe
                    probe = probe.next
                newNode = Node(item, probe)
                if trailer is None:
                    self._front = newNode
                else:
                    trailer.next = newNode
                self._size += 1

#input: unsorted list
#output: sorted list
def insertionSort(lyst):
  i = 1
  while i < len(lyst):
    key = lyst[i]
    j = i - 1
    while j >= 0 and key.id < lyst[j].id:
      lyst[j + 1] = lyst[j]
      j -= 1
    lyst[j + 1] = key
    i += 1



#input: unsorted list
#output: sorted list
def quickSort(lyst):
    quicksortHelper(lyst, 0, len(lyst) - 1)

def quickSortHelper(lyst, left, right):
    if left < right:
        pivotLocation = partition(lyst, left, right)
        quicksortHelper(lyst, left, pivotLocation - 1)
        quicksortHelper(lyst, pivotLocation + 1, right)

def partition(lyst, left, right):
    # Find the pivot and exchange it with the last item
    middle = (left + right) // 2
    pivot = lyst[middle]
    lyst[middle] = lyst[right]
    lyst[right] = pivot
    # Set boundary point to first position
    boundary = left
    # Move items less than pivot to the left
    for index in range(left, right):
        if lyst[index].id < pivot.id:
            swap(lyst, index, boundary)
            boundary += 1
    # Exchange the pivot item and the boundary item
    swap (lyst, right, boundary)
    return boundary

def swap(lyst, i, j):
    """Exchanges the items at positions i and j."""
    # You could say lyst[i], lyst[j] = lyst[j], lyst[i]
    # but the following code shows what is really going on
    temp = lyst[i]
    lyst[i] = lyst[j]
    lyst[j] = temp

"""##### **Classes for the Program**

###### **Hospital**
- The Hospital class represents an real-life hospital. The class is instantiated with a given capacity, representing the number of patients the hospital object can hold.
- The Hospital class has an add_patients() method that accepts a list of patients, and stores it in an instance variable. The class also has a add_doctor() method that takes a Doctor object as an argument, and adds it to a list of doctors stored within the class.
- The gendersort() method takes a string that represents a given specialty. The method goes through the patient list and assigns patients that need the given specialty's service, and assigns them to an appropriate doctor, taking into account the patient's gender preference. The assign_patients method calls this gendersort method for every specialty available in the hospital.
-Before assigning patients to doctors, the Hospital class can also sort patients by ID using the sort_id method. This method uses an Insertion Sort or a quick sort, depending on the size of the list of patients.

###### **Patient**
- Patient class represents a patient who needs to see a doctor.
- Patient class is instantiated with several instance variables, such as level of urgency, specialty required, ID number, and potential doctor gender preference.

###### **Doctor**
- Doctor class has attributes pertaining to each object's specialty, gender, and unique ID
- Data within doctor class is a linked-based priority queue that holds patient objects
- Pop method represents a patient being examined
- String representation produces list of patients in doctors' queue, in the order that the patients will be seen
"""

class Hospital:
  def __init__(self, capacity = 50):
    self.doctors = []
    self.patients = []
    self.specialtyList = ['Internal Medicine','Pediatrics','Cardiology','Oncology','Psychiatry','General Surgery','Gastroenterology','Gynecologist','Radiologist','Urologist']

    self.capacity = capacity #maximum number of patients the hospital can hold

  #input: none
  #output: print statements for each of the doctors in the system
  def status_report(self):
    for doctor in self.doctors:
      print(doctor)

  def num_patients(self):
    return len(self.patients)

  def num_doctors(self):
    return len(self.doctors)

  def print_patients(self):
    return "[" + ", ".join(map(str, self.patients)) + "]"

  #Input: None
  #Output: None
  #goes through each of the doctors in self.doctors and calls the sort method.
  def sort_id(self):
    if len(self.patients) > 24:
      insertionSort(self.patients)
    else:
      quickSort(self.patients)
    return "[" + ", ".join(map(str, self.patients)) + "]"

  #input: patient list to be added to hospital
  #output: none
  def add_patients(self, patients):
    self.patients += patients

  #input: doctor to add to the hospital
  #output: -1 if doctor is already in the hospital, none otherwise
  def add_doctor(self, doctor):
    if doctor not in self.doctors:
      self.doctors.append(doctor)
    else:
      return -1

  #Input: specialty as a string
  #Output: assigns patients to each doctor based on specialty and gender preference. If multiple doctors meet the criteria, assigned at random.
  def genderSort(self, specialty):
    tempDoctor = []
    for i in range(len(self.doctors)):
        if self.doctors[i]._specialty == str(specialty):
            tempDoctor.append(self.doctors[i])
        else:
            pass
    tempM = []
    tempF = []
    tempO = []

    for j in range(len(tempDoctor)):
        if tempDoctor[j]._gender == 'M':
            tempM.append(tempDoctor[j])
        elif tempDoctor[j]._gender == 'F':
            tempF.append(tempDoctor[j])
        else:
            tempO.append(tempDoctor[j])

    for i in range(len(patientList)):
        if self.patients[i].get_condition() == str(specialty):
            if self.patients[i].get_gender_preference() == 'M':
                if len(tempM) > 0:
                    rd.choice(tempM).add(self.patients[i])
            elif self.patients[i].get_gender_preference() == 'F':
                if len(tempF) > 0:
                    rd.choice(tempF).add(self.patients[i])
            elif self.patients[i].get_gender_preference() == 'Other':
                if len(tempO) > 0:
                    rd.choice(tempO).add(self.patients[i])
            else:
                if len(tempDoctor) > 0:
                    rd.choice(tempDoctor).add(self.patients[i])

  def assign_patients(self):
    for specialty in self.specialtyList:
      self.genderSort(specialty)

class Patient(object):

    def __init__(self, ID, condition, urgency = 1,gender_preference = None):
        self.id = ID
        #integer
        self.condition = condition
        #string condition
        self.urgency = urgency
        #integer from 1-5
        self.gender_preference = gender_preference
        #"Male" or "Female" or None

    def __str__(self):
        """The string representation of a patient instance"""
        # string = 'Patient ID: ' + str(self.id)
        string = f'''Patient ID:  {str(self.id)}, Condition: {str(self.condition)}, G_P: {str(self.gender_preference)}, Urgency: {str(self.urgency)}\n'''
        return string

    def get_condition(self):
        return self.condition

    def get_urgency(self):
        return self.urgency

    def get_gender_preference(self):
        return self.gender_preference

class Doctor(object):

    def __init__(self,ID,specialty,gender):
        self._ID = ID
        self._specialty = specialty
        self._gender = gender
        self._data = LinkedPriorityQueue()

    def __str__(self):
        """The string representation of a Doctor instance"""
        # string = 'Doctor ' + str(self._ID) + "'s list of patients: " + str(self._data)
        string = f'''Doctor {str(self._ID)} ({self._gender})'s list of patients ({str(self._specialty)}):\n {str(self._data)}\n'''
        return string

    def __len__(self):
        """-> The number of items in self."""
        return len(self._data)

    def add(self,patient):
        self._data.add(patient)

    def pop(self):
        self._data.pop()

"""##### **Functions Used by the Program**

Generates doctors and patients
"""

def generateDoctors(ID,specialtyIndex):
    genderList = ['M','F','Other']
    specialtyList = ['Internal Medicine','Pediatrics','Cardiology','Oncology','Psychiatry','General Surgery','Gastroenterology','Gynecologist','Radiologist','Urologist']
    return Doctor(ID,specialtyList[specialtyIndex],rd.choice(genderList))

def generatePatients(ID,conditionIndex,urgency,genderPrefIndex):
    condition = ['Internal Medicine','Pediatrics','Cardiology','Oncology','Psychiatry','General Surgery','Gastroenterology','Gynecologist','Radiologist','Urologist']
    #urgency = [1,2,3,4,5]
    genderPref = ['M','F','Other','None']
    return Patient(ID,condition[conditionIndex],urgency,genderPref[genderPrefIndex])

"""#### **Test Driver**

- Instantiates hospital object
- Generates 100 patients and 30 doctors with random attributes, and adds them to hospital object. More doctors with internal medicine attribute created to simulate greater proportion of generalists v. specialists
- Uses hospital class method to sort list of patients based on ID using either quick or merge sort algorithms depending on patient list size (ID represents patient admission date)
- Uses hopsital class method to assign each patient to a doctor based on patients' condition and gender preference. When assigned to a doctor, uses the Doctor class's add method, which will add the patient to each doctor object's priority queue based on patient condition's urgency  
- Final output is a queue for each doctor containing all patients each doctor will have to see, in the order of admission date and condition urgency
"""

# Generate hospital object

H = Hospital()

# Generate 21 internal medicine doctors, these would be the catch-all if there are no matching specialized doctors
for i in range(21):
    doctorToken = generateDoctors(i+1,0)
    H.add_doctor(doctorToken) #H[i] = H.add_doctor(doctorToken)

# Generate 9 specialized doctors
index = 1
for i in range(21,30):
    doctorToken = generateDoctors(i + 1,index)
    H.add_doctor(doctorToken)
    index += 1

# Create patient list of patients
patientList = []
numsOne = list(range(1, 71))
rd.shuffle(numsOne)
numsTwo = list(range(71, 101))
rd.shuffle(numsTwo)


# 70% patients generated with general conditions
for i in range(70):
    id = numsOne[i]
    conditionIndex = 0
    urgency = rd.randint(1,5)
    genderPrefIndex = rd.randint(0,3)
    patientToken = generatePatients(id,conditionIndex,urgency,genderPrefIndex)
    #print(str(patientToken))
    patientList.append(patientToken)

# 30% patients generated with conditions that require specialist's care
for i in range(30):
    id = numsTwo[i]
    conditionIndex = rd.randint(1,9)
    urgency = rd.randint(1,5)
    genderPrefIndex = rd.randint(0,3)
    patientToken = generatePatients(id,conditionIndex,urgency,genderPrefIndex)
    #print(str(patientToken))
    patientList.append(patientToken)

# Admitting unsorted list of patients to the hopsital
H.add_patients(patientList)
print('Number of patients in the hosopital: ',H.num_patients())
print('Number of doctors in the hospital: ',H.num_doctors())
print()

# Unsorted list of patients:
print("Unsorted list of patients in the hospital: ")
print(H.print_patients())
print()

# Sort the patients by ID (representing admission time):
print("Sorted list of patients by admission time: ")
print(H.sort_id())
print()

# Assign patients to doctors based on gender preference and condition/doctors' specialty
H.assign_patients()
H.status_report()
print()

# # Testing to see that each doctor's queue takes into account the urgency of each patient's problem & pop method (patient examined)
# for i in range(5):
#   if len(H.doctors[i]) != 0:
#     print(H.doctors[i])
#     j = 0
#     while len(H.doctors[i]) != 0:
#       print(H.doctors[i]._data.peek(),'Urgency: ',H.doctors[i]._data.pop().get_urgency())
#     print()

